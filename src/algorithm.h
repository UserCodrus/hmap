#pragma once

#include <vector>
#include <algorithm>

// Linear interpolation
inline float lerp(float t, float a, float b);
// Cosine interpolation
inline float corp(float t, float a, float b);
// Cubic interpolation
inline float curp(float t, float a[4]);
// Perlin smoothstep function
inline float fade(float t);

struct Vector2
{
	Vector2() : x(0.0f), y(0.0f) {};
	Vector2(float _x, float _y) : x(_x), y(_y) {};

	float x, y;
};

struct Vector3
{
	Vector3() : x(0.0f), y(0.0f), z(0.0f) {};
	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {};

	float x, y, z;
};

// A kd tree node for two dimensional data
template <class T>
struct KDNode2D
{
	KDNode2D(T* data);
	~KDNode2D();

	KDNode2D* l = nullptr;
	KDNode2D* r = nullptr;
	T* point = nullptr;
};

// A two dimensional kd tree
template <class T>
class KDTree2D
{
public:
	KDTree2D() {};
	~KDTree2D();

	// Build a new tree with a given list of points
	void build(std::vector<T>& data);
	// Find the nearest neighbor in the tree to the provided point
	const T* getNearest(const T& location) const;

private:
	// Add a new node to the tree using the provided data sample
	KDNode2D<T>* addNode(std::vector<T>& data, typename std::vector<T>::iterator begin, typename std::vector<T>::iterator end, bool xaxis = true);

	// The tree's root node
	KDNode2D<T>* root = nullptr;
};

// The square of the distance between two vectors in the x and y dimensions
template <class T>
inline float distance2D(const T& a, const T& b);

class Noise
{
public:
	unsigned getWidth() const;
	unsigned getHeight() const;

protected:
	unsigned width;
	unsigned height;
};

// Noise generated by creating a grid of gradient vectors
class GradientNoise : public Noise
{
public:
	GradientNoise(unsigned _width, unsigned _height, unsigned seed);
	~GradientNoise();

	Vector2 getGradient(unsigned x, unsigned y) const;

	// Get Perlin noise at the specified coordinate
	float perlin(float x, float y) const;

protected:
	Vector2* gradient = nullptr;
};

// Noise generated by creating a grid of random values
class ValueNoise : public Noise
{
public:
	ValueNoise() {};
	ValueNoise(unsigned _width, unsigned _height, unsigned seed);
	~ValueNoise();

	float getValue(unsigned x, unsigned y) const;

	// Bilinear interpolated noise
	float linear(float x, float y) const;
	// Cosine interpolated noise
	float cosine(float x, float y) const;
	// Cubic interpolated noise
	float cubic(float x, float y) const;

protected:
	float* value = nullptr;
};

// A value noise grid created using the diamond square algorithm
class PlasmaNoise : public ValueNoise
{
public:
	PlasmaNoise(unsigned size, unsigned seed);
};

// Noise generated by choosing random points in a given area
class PointNoise : public Noise
{
public:
	PointNoise() {};
	PointNoise(unsigned num_points, unsigned seed);
	//~PointNoise();

	// Sample point noise at the given coordinates
	virtual float dot(float x, float y) const;
	// Sample raw Worley noise at the given coordinates
	virtual float worley(float x, float y) const;

	// Set the sample bias
	void setBias(float value);

protected:
	// The distance from the nearest point required to produce the maximum noise value from a sample
	float bias = 0.0f;

private:
	// The generated point array
	std::vector<Vector2> point;
	// A kd tree used for nearest neighbor searches of point data
	KDTree2D<Vector2> tree;
};

class GridNoise : public PointNoise
{
public:
	GridNoise(unsigned _width, unsigned _height, unsigned seed);
	~GridNoise();

	// Get the point in the provided grid cell
	inline Vector2 getPoint(unsigned x, unsigned y) const;
	// Get the nearest point to the provided coordinates
	inline Vector2 getNearest(Vector2 location) const;

	// Sample point noise at the given coordinates
	float dot(float x, float y) const override;
	// Sample raw Worley noise at the given coordinates
	float worley(float x, float y) const override;

private:
	// The point array
	Vector2* points = nullptr;
	// The number of points in the array
	unsigned num_points = 0;
};

#include "algorithm.inl"